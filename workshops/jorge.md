# Title: Practical Software Engineering for the busy Computational Chemist: FAIR principles for data and software 

## Abstract: In this workshop, attendees will learn a series of practical skills related to software engineering and how they are related to their work in the computational chemistry domain. The workshop will highlight code as a byproduct of research and the importance of making data and programs FAIR: Findable, Accessible, Interoperable, and Reusable. 

## Requirements: The workshop is targeted to any audience with a focus on beginners with little knowledge about software engineering and best practices. The only assumed knowledge is Linux command line use, including being able to use ssh to connect to a remote cluster and use vim/emacs/nano to edit text remotely. Efficient use of VSCode can replace this. 
1. **Introduction to software as byproduct of research endeavours**
   a. Code produced to automate workflows  
   b. Code produced to automate creation of input files  
   c. Code produced to automate analysis of results  

2. **Software as the main product of research endeavours**
   a. New methodologies of computation, analysis, workflows  
   b. Integration into larger software packages versus standalone use  

3. **Licenses, copy left, open source, free software, intellectual property**
   a. Non-legal discourse on what it means to be open source and free software  
   b. Copy left licenses, pros and cons  
   c. How to license your code  

4. **Best practices in software development**
   a. Version control — brief intro to Git on demand  
   b. Build systems and dependency management  
   c. Reproducibility of builds on different platforms  
   d. Documentation of code  

5. **FAIR code/data**
   a. Principles of FAIR software and data — why does it matter?  

6. **Programming languages**
   a. A brief summary of those you might encounter and how they are different  
   b. Prototyping versus production software  
      i. Deliver what you need for your research — define your goals  

7. **Agentic coding, LLMs, and internet buzzwords (“vibe coding”)**
   a. Why should I code if the LLM can do it for me?  
   b. Why should I not listen to the LLM when coding?  
   c. A balance in the force  


a. Why should I code if the LLM can do it for me?
b. Why should I not listen to the LLM when coding?
c. A balance in the force
